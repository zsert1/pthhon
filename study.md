### 복잡도  
  - 알고리즘 성능을 나타내는 척도
     - 시간 복잡도: 특정 크기의 입력에 대하여 알고리즘 수행 시간 분석
     - 공간 복잡도: 메모리 사용량 분석 
     - 복잡도 낮을수록 좋다  

### 빅오 표기법
  - 가장 빠르게 증가하는 항만을 고려하는 표기법  

### 시간 복잡도 순위  
- O(1) 상수시간=> O(log N) 로그 시간 => O(N)선형시간 => O(NlogN)로그 선형시간 => O(N^2)이차시간 => O(N^3) 삼차시간=> O(2^n) 지수시간 

## 알고리즘 설계 TIP
일반적인 CPU기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산횟수 5억을 넘기는 경우
- 파이썬 기준 5~15초 소요  
- 시간 초과 경우 pypy로 변경해서 제출   
- 코딩 테스트 에서는**1~5초** 가량으로 연산되도록 계산  

## 문제 확인
 - 가장 먼저 확인할 내용은 **시간제한**(수행시간 요구사항)
 - 시간 제한 1초인 경우
   -  N의 범위가 **500**인 경우 => 시간 복잡도가 **O**(**N^3**)인 알고리즘 설계
   -  N의 범위가 **2,000**인 경우 => 시간 복잡도가 **O**(**N^2**)인 알고리즘 설계
   -  N의 범위가 **100,000**인 경우 => 시간 복잡도가 **O**(**NlogN**)인 알고리즘 설계
   -  N의 범위가 **10,000,000**인 경우 => 시간 복잡도가 **O**(**N**)인 알고리즘 설계

## 문제 해결 과정
 - 지문 읽기 컴퓨터 사고
 - 요구사항(복잡도) 분석
 - 문제 해결 위한 아이디어 찾기
 - 소스코드 설계 및 코딩 

 ## 자료형 리스트
  - 연속적인 위치에 원소들을 가지고 와야할 때 **슬라이싱** 이용
  - 대괄호 안에 콜론(:)을 넣어서 시작 인덱스와 끝 인덱스 설정 가능
  - 끝 인덱스는 실제 인덱스 보다 1을 더 크게 설정 
  - 예시 : a = [1,2,3,4,5,6,7,8,9,] print(a[1:4])
  - 대괄호 안에 조건문과 반복문 적용하여 리스트 초기화 가능(리스트 컴프레션)
  - 예시: arr=[i for i in range(10)]
  - 2차원 리스트를 한 번에 초기화 할때 매우 유용하다.
  - 예시 : a= [[0]*m for _ in range[n] ]
  - 언더바 사용은 반복을 수행하되 반복을 위한 변수의 값을 무시할 때 언더바 사용 
  - 변수를 사용할 필요없는 작업 
  - 함수 정리
    - append() : 리스트에 원소를 삽입할 때 사용 O(1)
    - sort(): 기본 정렬 오름차순으로   O(log N)
    - sort(reverse= True): 기본 정렬 내림차순으로  O(log N)
    - reverse: 리스트의 원소의 순서를 뒤집는다   O(N)
    - insert(삽입 위치 인덱스,삽입할 값): 특정 인덱스 위치에 특정 값 삽입 시  O(N)
    - count(특정값): 특정 값의 갯수 확인 O(N)
    - romove(특정값): 특정 값을 갖는 원소제거, 특정 값 여러개면 하나만 제거 O(N)
    - 특정 값 모두 제거 : 집합 자료형 만든다 => 리스트 컴프레션 이용하여 집합 자료형에 있다면 지워준다