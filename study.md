### 복잡도  
  - 알고리즘 성능을 나타내는 척도
     - 시간 복잡도: 특정 크기의 입력에 대하여 알고리즘 수행 시간 분석
     - 공간 복잡도: 메모리 사용량 분석 
     - 복잡도 낮을수록 좋다  

### 빅오 표기법
  - 가장 빠르게 증가하는 항만을 고려하는 표기법  

### 시간 복잡도 순위  
- O(1) 상수시간=> O(log N) 로그 시간 => O(N)선형시간 => O(NlogN)로그 선형시간 => O(N^2)이차시간 => O(N^3) 삼차시간=> O(2^n) 지수시간 

## 알고리즘 설계 TIP
일반적인 CPU기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산횟수 5억을 넘기는 경우
- 파이썬 기준 5~15초 소요  
- 시간 초과 경우 pypy로 변경해서 제출   
- 코딩 테스트 에서는**1~5초** 가량으로 연산되도록 계산  

## 문제 확인
 - 가장 먼저 확인할 내용은 **시간제한**(수행시간 요구사항)
 - 시간 제한 1초인 경우
   -  N의 범위가 **500**인 경우 => 시간 복잡도가 **O**(**N^3**)인 알고리즘 설계
   -  N의 범위가 **2,000**인 경우 => 시간 복잡도가 **O**(**N^2**)인 알고리즘 설계
   -  N의 범위가 **100,000**인 경우 => 시간 복잡도가 **O**(**NlogN**)인 알고리즘 설계
   -  N의 범위가 **10,000,000**인 경우 => 시간 복잡도가 **O**(**N**)인 알고리즘 설계

## 문제 해결 과정
 - 지문 읽기 컴퓨터 사고
 - 요구사항(복잡도) 분석
 - 문제 해결 위한 아이디어 찾기
 - 소스코드 설계 및 코딩.    
  
## 자료형 리스트
  - 연속적인 위치에 원소들을 가지고 와야할 때 **슬라이싱** 이용
  - 대괄호 안에 콜론(:)을 넣어서 시작 인덱스와 끝 인덱스 설정 가능
  - 끝 인덱스는 실제 인덱스 보다 1을 더 크게 설정 
  - 예시 : a = [1,2,3,4,5,6,7,8,9,] print(a[1:4])
  - 대괄호 안에 조건문과 반복문 적용하여 리스트 초기화 가능(리스트 컴프레션)
  - 예시: arr=[i for i in range(10)]
  - 2차원 리스트를 한 번에 초기화 할때 매우 유용하다.
  - 예시 : a= [[0]*m for _ in range[n] ]
  - 언더바 사용은 반복을 수행하되 반복을 위한 변수의 값을 무시할 때 언더바 사용 
  - 변수를 사용할 필요없는 작업 
  - 함수 정리
    - append() : 리스트에 원소를 삽입할 때 사용 O(1)
    - sort(): 기본 정렬 오름차순으로   O(log N)
    - sort(reverse= True): 기본 정렬 내림차순으로  O(log N)
    - reverse: 리스트의 원소의 순서를 뒤집는다   O(N)
    - insert(삽입 위치 인덱스,삽입할 값): 특정 인덱스 위치에 특정 값 삽입 시  O(N)
    - count(특정값): 특정 값의 갯수 확인 O(N)
    - romove(특정값): 특정 값을 갖는 원소제거, 특정 값 여러개면 하나만 제거 O(N)
    - 특정 값 모두 제거 : 집합 자료형 만든다 => 리스트 컴프레션 이용하여 집합 자료형에 있다면 지워준다.  
## 튜플 자료형
  - 한 번 선언된 값을 변경할 수 없다
  - 튜플은 리스트에 비해 공간 효율적이다.
  - 초기화 방법 a= (1,2,3,4,5,6)
  - 사용하면 좋은 경우 
    - 서로 다은 성질의 데이터를 묶어서 관리 할 때
      - 최단 경로 알고리즘(비용,노드 번호)
    - 데이터의 나열을 해싱의 키 값으로 사용할 때
      - 튜플은 변경이 불가능 하므로 리스트와 다르게 **키 값**으로 사용가능하다.
    - 리스트보다 메모리를 효율적으로 사용해야 할 때  
## 사전 자료형
  - 키와 값의 쌍을 데이터로 가지는 자료형
    - 리스트와 튜플과 다르게 순차적으로 저장하는 것과 대비
  - 변경 불가능 한 자료형을 키로 사용가능
  - 사전 자료형은 해시 테이블을 이용하므로 데이터 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다
  - 예시  `data=dict() data[key]= value   
   if 'key' in data:  
      print("'key를 가진 데이터 존재 '")
   `
  - 사전 자료형에서 키 값을 따로 뽑을때 keys()사용 ,값만 따로 values()함수 사용  
    => 리스트 형태로 형 변환 해주어야 리스트 형태로 나온다. => key_list= list(b.keys())

## 집합 자료형
  - 중복을 허용하지 않는다.
  - 순서가 없다
  - 집합은 리스트 혹은 문자열 이용하여 초기화
    -  이때 set()함수를 이용한다.
    - 혹은 중괄호({})안 에 각 원소에 콤마(.)를 기준으로 구분하여 삽입함으로써 초기화 할 수 있다.  
  - 데이터 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다. 
  - 예시 data=set([1,2,2,3,4,5,5]),  data={1,2,2,3,4,5,5}
  - 합집합(|),교집합(&),차집합(-) 연산 등이 가능하다  
  - 새로운 원소 추가:  add(value)
  - 새로운 원소 여러개 추가: updata([a,b,c])
  - 특정 원소 제거:remove(지울값)

### 사전 자료형과 집합 자료형의 특징
  -  리스트나 튜플은 순서 존재하기 때문에 인덱싱 통해 자료형의 값을 얻을 수 있다.
  - 사전 자료형과 집합 자료형은 **순서가 없기 때문에** 인덱싱으로 값을 얻을 수 없다
    - 사전의 키 혹은 집합의 원소를 이용하여 **O(1)** 시간의 복잡도로 조회

### 입출력 
  - input() 함수는 한 줄의 문자열을 입력받는 함수
  - map()함수는 리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용
    - 예시) 공백 기준으로 구분된 데이터 list(map(int,input.split()))
    - 공백 기준으로 구분된 데이터의 개수가 많지 않다면  
     =>` a, b, b=map(int, input,split())`  
  - 입력을 위한 전형적인 소스코드
    - ` n= int(input())`  
       `data= list(map(int,input(),split)`  
       `data.sort(reverse=True)`  
      `print(data)`

### 빠르게 입력 받기
  - 시영자로부터 입력을 최대한 빠르게 받아야 하는 경우
  - 파이썬의 경우 sys라이브러리에 있는 sys.stdin.readline() 이용
    - 엔터 이후 줄 바뀜 기호 입력되므로 rstrip() 메서드 함께 사용되어야 한다.  

### 표준 출력 방법
  - 기본 출력은 print() 이용하고 ,로 구분
  - end 속성으로 빈 문자열 입력하면 줄 바꿈 안됨
  - 문자열 앞에 접두사 'f'를 붙이면 +쓸 필요없다.

### 조건문 
 - `if 조건문:  `  
      `실행문`
 - 파이썬은 코드의 블록을 **들여쓰기**로 지정한다.
 - 가이드 라인에서는 **4개의 공백문자**를 사용하는 것을 표준
 - 파이썬에서는 else if 를 **elif**로 사용한다.     
 - X in 리스트 연산자 => x in 리스트 
 -  X not in 문자열
 - 아무것도 처리하고 싶지 않을 때 **pass**키워드 사용  
 - 코드가 한 줄인 경우 즐 비꿈 없이 간략하게 사용가능 
 - 조건 부 표현 식 x= True일때 조건문 False일때  
 ### 반복문
  - for문에서 연속적인 값을 차례대로 순회 할때는 range(시작 값, 끝 값 +1)주로 사용
    - 예) for i in range(1,10) => 1부터 9까지
  - continue 키워드  남은 코드의 실행을 건너띄고 ,다음 반복을 진행할때
    - 예)  홀 수의 핪  
       => result=0  
          for i in rnage(1,10)  
          if i%2 ==0  
          continue  
          result +=i  
  - break는 반복문을 즉시 탈출 

  ### 함수
   - 정의하기 => def 함수명(): 
     - `def 함수명(매개변수):  
            실행할 소스코드  
            return`  
   - 함수의 바깥에 선언된 변수를 **global** 키워드를 이용하여 변수를 사용할 수 있다.
   - 함수는 여러개의 반환 값을 가질 수 있다
   - 람다 표현식 => 특정한 기능을 수행하는 함수를 한 줄에 작성할 수 있다.
      - 단순히 한 번만 사용할때 사용
      - 예시) (lambda a,b:a+b(3,7))

  ### 내장함수
  - 순열: 서로 다른 n 개에서 서로 다른 r 개를 선택하여 나열(순서를 고려한다)
    - from itertools import permutations 사용
    - `data = ['a','b','c']`  
      `result =list(permutations(data,3))`
  - 조합: 서로 다른 n 개에서 서로 다른 r 개를 선택하여 나열(순서를 고려안한다)
    - from itertools import combinations 사용
    - `data = ['a','b','c']`  
      `result =list(combinations(data,2))`
  - count(): 내부의 원소가 몇 번 등장했는지
    -  from collections import Counter
  - 최대 공약수: gcd()
  - 최소 공배수 구하는 함수
     - `def lcm(a,b):  
     return a*b//math.gcd(a,b)`

  ### 그리디 알고리즘
  -  단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토가 필요하다.
  -  탐욕법으로 얻은 해가 최적의 해가 되는 상황에서 이를 추론가능
  -  거스름 돈 문제 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들은 종합해 다른 해가 나올 수 없기 때문
  - 나올 문제: 어떠한 수 N이 1이 될 때까지
    - N과 K가 주어질때 N이 1이 될 때까지 1 번 혹은 2번의 **과정을 수행해야 하는 최소 횟수** 를 구하는 프로그렘
   


            